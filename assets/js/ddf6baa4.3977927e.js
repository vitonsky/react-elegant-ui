"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[592],{5288:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=t(5893),r=t(1151);const o={},s="Component naming and structure",c={id:"Component development/ComponentNaming",title:"Component naming and structure",description:"Names must be clear and unambiguous. It helps you to navigate in large number of objects and simplify supporting.",source:"@site/../docs/Component development/ComponentNaming.md",sourceDirName:"Component development",slug:"/Component development/ComponentNaming",permalink:"/react-elegant-ui/Component development/ComponentNaming",draft:!1,unlisted:!1,editUrl:"https://github.com/vitonsky/react-elegant-ui/tree/master/docs/../docs/Component development/ComponentNaming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",next:{title:"Design system style guide",permalink:"/react-elegant-ui/Component development/DesignSystem"}},l={},d=[{value:"Common principles",id:"common-principles",level:2},{value:"Exported interfaces should start from prefix <code>I</code>",id:"exported-interfaces-should-start-from-prefix-i",level:3},{value:"Name entities by meaning and not by content",id:"name-entities-by-meaning-and-not-by-content",level:3},{value:"Block",id:"block",level:2},{value:"Interface",id:"interface",level:3},{value:"Component",id:"component",level:3},{value:"Feature HOC",id:"feature-hoc",level:3},{value:"Class name constructor",id:"class-name-constructor",level:3},{value:"Element",id:"element",level:2},{value:"Interface",id:"interface-1",level:3},{value:"Context",id:"context",level:3},{value:"Component",id:"component-1",level:3},{value:"Modifier",id:"modifier",level:2},{value:"Interface",id:"interface-2",level:3},{value:"HOC",id:"hoc",level:3},{value:"Dependency injection registry",id:"dependency-injection-registry",level:2},{value:"Interface",id:"interface-3",level:3},{value:"Registry",id:"registry",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"component-naming-and-structure",children:"Component naming and structure"}),"\n",(0,i.jsx)(n.p,{children:"Names must be clear and unambiguous. It helps you to navigate in large number of objects and simplify supporting."}),"\n",(0,i.jsx)(n.p,{children:"When object names obey this rules, you always be understand what you use just by name and refactor be easy."}),"\n",(0,i.jsx)(n.h2,{id:"common-principles",children:"Common principles"}),"\n",(0,i.jsx)(n.p,{children:"Names of all interfaces and exported blocks and elements should be CamelCase"}),"\n",(0,i.jsxs)(n.h3,{id:"exported-interfaces-should-start-from-prefix-i",children:["Exported interfaces should start from prefix ",(0,i.jsx)(n.code,{children:"I"})]}),"\n",(0,i.jsx)(n.p,{children:"This way make search in IDE more easy and assist to understand type of imported object and different interface from JS object."}),"\n",(0,i.jsx)(n.h3,{id:"name-entities-by-meaning-and-not-by-content",children:"Name entities by meaning and not by content"}),"\n",(0,i.jsxs)(n.p,{children:["For example modifier ",(0,i.jsx)(n.code,{children:"Component_view_error"})," instead ",(0,i.jsx)(n.code,{children:"Component_view_red"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It important for independency names from values. For example, color of action button may be different in some projects and you should abstract it."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"block",children:"Block"}),"\n",(0,i.jsx)(n.h3,{id:"interface",children:"Interface"}),"\n",(0,i.jsx)(n.p,{children:"Block must export interface with own props."}),"\n",(0,i.jsx)(n.p,{children:"It needs to able create other implementation of element and interact with block from other objects."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"I + ComponentName + Props"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IButtonProps"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ITabMenuProps"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"component",children:"Component"}),"\n",(0,i.jsxs)(n.p,{children:["Block must export object of type ",(0,i.jsx)(n.code,{children:"React.ComponentType"})," which implement own interface."]}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"ComponentName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Button"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"TabMenu"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"feature-hoc",children:"Feature HOC"}),"\n",(0,i.jsx)(n.p,{children:"Block features may export HOC for apply this feature on base implementation of block."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"with + ComponentName + FeatureName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"withMenuDesktop"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"withSelectDesktop"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"class-name-constructor",children:"Class name constructor"}),"\n",(0,i.jsxs)(n.p,{children:["Block must export function which construct ",(0,i.jsx)(n.code,{children:"className"})," property value for elements and modifiers"]}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"cn + ComponentName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"cnButton"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"cnTabMenu"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"element",children:"Element"}),"\n",(0,i.jsx)(n.h3,{id:"interface-1",children:"Interface"}),"\n",(0,i.jsx)(n.p,{children:"Element must export interface with own props."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"I + ComponentName + ElementName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IButtonText"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ITabMenuItemText"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"context",children:"Context"}),"\n",(0,i.jsx)(n.p,{children:"Element may export context object which implement own interface."}),"\n",(0,i.jsx)(n.p,{children:"It need to simplify deep forward props."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"ComponentName + ElementName + Context"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SelectTriggerContext"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SelectListContext"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"component-1",children:"Component"}),"\n",(0,i.jsxs)(n.p,{children:["Element must export object of type ",(0,i.jsx)(n.code,{children:"React.ComponentType"})," which implement own interface."]}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"ComponentName + ElementName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ButtonText"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"TabMenuItemText"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"modifier",children:"Modifier"}),"\n",(0,i.jsx)(n.h3,{id:"interface-2",children:"Interface"}),"\n",(0,i.jsx)(n.p,{children:"Modifier must export interface with props which add."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"IMod + ComponentName + ModName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModButtonViewDefault"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IModTabMenuViewAction"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hoc",children:"HOC"}),"\n",(0,i.jsx)(n.p,{children:"Modifier must export HOC for apply to block."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"withMod + ComponentName + ModName"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"withModButtonViewAction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"withModTabMenuViewDefault"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"dependency-injection-registry",children:"Dependency injection registry"}),"\n",(0,i.jsx)(n.h3,{id:"interface-3",children:"Interface"}),"\n",(0,i.jsx)(n.p,{children:"Registry must export interface with items which it contains."}),"\n",(0,i.jsx)(n.p,{children:"Feature specific registry (like platform registry) may extend common registry interface and add or redefine some items."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"I + ComponentName + FeatureName + Registry"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IButtonRegistry"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ITabMenuRegistry"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example with feature scope"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"IButtonDesktopRegistry"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ITabMenuExperementalIconsRegistry"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"registry",children:"Registry"}),"\n",(0,i.jsx)(n.p,{children:"All registries (except index files) must export registry object."}),"\n",(0,i.jsxs)(n.p,{children:["Name pattern: ",(0,i.jsx)(n.code,{children:"ComponentName + FeatureName + Registry"})]}),"\n",(0,i.jsx)(n.p,{children:"Example"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ButtonRegistry"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"TabMenuRegistry"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example with feature scope"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"ButtonDesktopRegistry"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"TabMenuExperementalIconsRegistry"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Also, registry file may export object ",(0,i.jsx)(n.code,{children:"regObjects"})," which contains all dependency objects"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var i=t(7294);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);