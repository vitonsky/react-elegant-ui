{"pageProps":{"title":"Component development","date":1626904699572,"text":"<!-- TODO: split by headers -->\n\n# Component development\n\nHere explain how to write good components, easy for maintenance.\n\n***\n\n# Common recomendation\n\n## Use strict typing\n\nComponents written on typescript because strict types simplify maintenance.\n\nWhen you wrong - you just can't compile code and in many cases you even don't need to check types in runtime, because successful compilation guarantee you many things.\n\nBut guarantees require high quality code with types which reflect domain specific.\n\nTherefore you must write real types and try avoid `any` type, type casting and other hacks.\n\nTypescript is very flexible language and allow you make complexity types. Usually TS features enought for any case. If you can't express something, check [typescript docs](https://www.typescriptlang.org/docs/) or make issue to discuss your problem.\n\n## Write stupid code\n\nMaintain complexity is very important parameter of code, it's literally define future of code base.\n\nCode complexity and its diversity is a key factors of code base hard for maintenance.\n\nThe simply stupid code the better. Under stupid mean its clear and simplicity.\n\nWe can use linters and tools which control codestyle, but we can't prevent all cases with complexity code, especially since sometime we have to write complexity code for performance purposes.\n\nPlease, don't write beautiful and smart code which require time to understand.\n\nYour code must be simple, obviously and monosemantic. What would people read it and don't think what means your construction.\n\nFor example, `x === -1` better than `!~x`, because we shouldn't parse syntax and build logical pipeline with negation of negation, follow the logic and other things. We just see statement and understand it instantly.\n\nYour code is nothing and will replace in any time. At least because tomorrow it will be deprecated. Keep it in mind when write code and focus on functionality and clearly. Functional will keep forever.\n\n## Comment all\n\nIf you have to write not trivial code or use hack, explain it.\n\nWhen you make public essence such as function, class or other object, add doc block for it.\n\nWhen you change a exists public essence and it change behavior or signature, update description of it.\n\nIf you not wanna do something right now, but see that it needful or would be usefull, make TODO comment with explain of it.\n\nIf you don't sure about something, comment it and say about. It's fine, someone later improve it, maybe you or not.\n\nIf you see suboptimal things, make TODO comment with tag #perf and explain problems. Criticism to code it's fine and help to make code better. But please, explain points, but not just insult a code because it useless information.\n\n## Specify licenses and authors for thirdparty resources\n\nWe respect authors of thirdparty resources and require specify license and authors for any thirdparty resources. Not matter what is it. It may be icons, fonts, images, libraries, parts of code or other. You must add this information for any resource and resource license must allow use resource anywhere.\n\nRemember that you are responsible for check licenses and author rights. If you find resource on some random site and there say that this resource is free to use anywhere it's mean nothing. You must reference to source of each resource and this must contains license agreement.\n\nThis is to ensure fair usage.\n\n***\n\n# Components development principles\n\nFor info about development components see [component naming and structure](</docs/Component development/ComponentNaming>).\n\nMore info about components in [component anatomy](/docs/Introduction/ComponentArchitecture) and [component file structure](/docs/Introduction/ComponentFileStructure).\n\nIf you still don't, must read [BEM methodology](https://en.bem.info/methodology/) to understand terms and architecture of components.\n\n## Blocks\n\nFor control a class names of components use library [@bem-react/classname](https://github.com/bem/bem-react/tree/master/packages/classname), make cn object in basic implementation of component and use it in other essences.\n\n### Minimal implementation\n\nBlock it's root of component and should implement minimal common features of component.\n\nIf you want implement feature which will use only on desktop, such as keyboard navigation, do it in feature file with feature name postfix in name, for example `Button@desktop.tsx`, `Button@touch.tsx`, `Button@someExperementName.tsx`.\n\n## Elements\n\nMove all elements to separate components, even if it very simply block.\n\nIt need to user can replace element to other implementation.\n\n## Modifiers\n\nModifiers should be a High Order Components (HOC).\n\nModifiers should self remove all own props which not declared in basic block interface and don't forward it.\n\n<!-- TODO: write docs for \"compose\" library and add link here -->\n\nYou can use compose library to define HOCs which will apply by match props values and auto remove own properties when not match.\n\n***\n\n# Reuse\n\n## Keep state outside\n\nKeep state outside and make requests to change state inside.\n\nIf don't do it, component will keep private state and wrappers can't control component and component stay unextendable.\n\nYou can keep inside a state which specific only for this entity, but all public properties states must keep outside.\n\n## Split to features\n\nComponent can't have features for any case, because number of cases is infinity.\n\nInstead this component should be designed extensible and implement only basic features.\n\nAll other may be implement as wrappers which add features.\n\nThis design allows add features for any case.\n\nDefault implementation of some feature in library don't like for you? It's fine, you don't need to fork library, replace some details in this implementation and support it self, just replace feature to your own implementation and it all. You can copy code of default implementation, replace details and use as your own feature which work as you wish.\n\nIf basic block layout bad for your case, just use your own implementation, you need only replace it with compose.\n\n## Use wrappers\n\nWhen you implement block feature, you need block to wrap it. But you must not direct use block inside implementation. It make feature not applyable for other block implementation.\n\nInstead this make HOC for block, export it, apply to block and export wrapped block.\n\nThis way allow to user apply this feature to any block which implement interface of basic block.\n\n## Move common logic outside\n\nSome UI logic need in many components. When you catch this, just move this logic to library, unify it and use library in same cases.\n\nBetter if you make library which not bind to framework and then adopt it to this, for example make behavior hook. This way allow you collect behavior logic and use it indepedent of framework features and even indepedent of framework, for example in pure JS.\n\nGood example of this it is [popperjs](https://popper.js.org) which can be use in pure js, react or any other library.\n\n## Use common interfaces\n\n<!-- TODO: write docs for common interfaces and add link here -->\n\nWhen interface have typical properties, use extends the coommon interfaces like `IComponentElement`\n\nThis unify properties and simplify global refactoring, because you can refactor only one interface and changes will apply to all implementations\n\n## Make extenson nodes\n\nWhen you build component think about how users may want extend this.\n\nTo extend component often need add child nodes, then add props which give component and render in some place inside.\n\nYou can use names start from `addon`: `addonBefore`, `addonAfter`, `addonBeforeControl`, `addonAfrerWrapper`\n\n## Forward all\n\nWhen you make wrapper, probably you insert to basic element some props.\n\nDon't forget forward user props with same names. You should make mix from your value and user value.\n\nIf it class name join it, if it callback, make call chain from your and user callback, if it context, mix context values but don't lose user values.\n\n## Class component vs functional\n\nYou can make components of any type, class components, functional components or both.\n\nBut functional components have hooks and very convenient move common ligic to hooks and use it everywhere.\n\nAlso, functional components is simply, so this library use mostly functional components.\n\nBut you can mix this.\n\n***\n\n# Abstract components and replaceable\n\n*   [Use design tokens](/docs/Introduction/Tokens)\n\n## Component incapsulation and autonomy\n\nComponent it's standalone entity and must be indepedent from all other.\n\nIt mean that component must contain all self parts such as code, styles, design tokens, docs, and other resources.\n\nComponent must consist from parts which can be replace to other implementations and end features can be define only while make bundle.\n\n## Use contexts to props forwarding\n\nComponents may use many wrappers and to forward props to some element you should use contexts.\n\nJust make context contains props while make element and use it inside. And when you need to set props on element, use context provider for it.\n\n## Use DI\n\n<!-- TODO: write docs about DI library and principles -->\n\nWhen you need some object, like element, you shall not use it directly never.\n\nInstead this use dependency injection containers.\n\nIt allows you replace objects while composing.\n\nDon't make types for DI which have all possible objects. Instead make type for basic components and standalone types for each feature and union this types while make bundle.\n\nThis way allows to users set only necessary objects in their registry.\n\nSee more info in [DI library docs](https://github.com/bem/bem-react/tree/master/packages/di)\n","navigation":[{"title":"Introduction","child":[{"title":"About","path":"/docs/Introduction/About"},{"title":"Getting started","path":"/docs/Introduction/GettingStarted"},{"title":"Package structure","path":"/docs/Introduction/PackageStructure"},{"title":"Component architecture","path":"/docs/Introduction/ComponentArchitecture"},{"title":"Component file structure","path":"/docs/Introduction/ComponentFileStructure"},{"title":"Theming","path":"/docs/Introduction/Theming"},{"title":"Tokens","path":"/docs/Introduction/Tokens"}]},{"title":"Component development","child":[{"title":"Introduction","path":"/docs/Component development/Introduction"},{"title":"Component naming","path":"/docs/Component development/ComponentNaming"},{"title":"Design system","path":"/docs/Component development/DesignSystem"},{"title":"Notes","path":"/docs/Component development/Notes"}]},{"title":"Contributing","child":[{"title":"Contributing rules","path":"/docs/Contributing/ContributingRules"},{"title":"CLA","path":"/docs/Contributing/CLA"}]}]},"pages":[],"__N_SSG":true}