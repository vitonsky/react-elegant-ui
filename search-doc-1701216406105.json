{"searchDocs":[{"title":"Developer notes","type":0,"sectionRef":"#","url":"/react-elegant-ui/Component development/Notes","content":"","keywords":"","version":"Next"},{"title":"Styles​","type":1,"pageTitle":"Developer notes","url":"/react-elegant-ui/Component development/Notes#styles","content":" Use CSS properties instead specific values everywhere when it possible, except specific cases like positioning with specify indents for each node.  All local CSS properties are defined in token files inside component directory, global properties define in token files in theme directory.    ","version":"Next","tagName":"h2"},{"title":"Abstraction​","type":1,"pageTitle":"Developer notes","url":"/react-elegant-ui/Component development/Notes#abstraction","content":" Objects and interfaces should implement and extends common objects, like IComponentElement for example. It simplify control on many entities and decrease code complexity.  All components which use similar interfaces should be unify, make common interface and use it.  All blocks must have property innerRef for forwarding ref objects to block wrapper.    ","version":"Next","tagName":"h2"},{"title":"Use root node instead document​","type":1,"pageTitle":"Developer notes","url":"/react-elegant-ui/Component development/Notes#use-root-node-instead-document","content":" When component use inside ShadowDOM, its root is not document and property event.target from event of document will contain ShadowDOM wrapper, but not real target inside this.  Consider this, and use document only for really global event handlers without root context, such as release mouse or button, but when need access to event.target - use node.getRootNode(), for component stay work in ShadowDOM. ","version":"Next","tagName":"h2"},{"title":"Component naming and structure","type":0,"sectionRef":"#","url":"/react-elegant-ui/Component development/ComponentNaming","content":"","keywords":"","version":"Next"},{"title":"Common principles​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#common-principles","content":" Names of all interfaces and exported blocks and elements should be CamelCase  ","version":"Next","tagName":"h2"},{"title":"Exported interfaces should start from prefix I​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#exported-interfaces-should-start-from-prefix-i","content":" This way make search in IDE more easy and assist to understand type of imported object and different interface from JS object.  ","version":"Next","tagName":"h3"},{"title":"Name entities by meaning and not by content​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#name-entities-by-meaning-and-not-by-content","content":" For example modifier Component_view_error instead Component_view_red.  It important for independency names from values. For example, color of action button may be different in some projects and you should abstract it.    ","version":"Next","tagName":"h3"},{"title":"Block​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#block","content":" ","version":"Next","tagName":"h2"},{"title":"Interface​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#interface","content":" Block must export interface with own props.  It needs to able create other implementation of element and interact with block from other objects.  Name pattern: I + ComponentName + Props  Example  IButtonPropsITabMenuProps  ","version":"Next","tagName":"h3"},{"title":"Component​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#component","content":" Block must export object of type React.ComponentType which implement own interface.  Name pattern: ComponentName  Example  ButtonTabMenu  ","version":"Next","tagName":"h3"},{"title":"Feature HOC​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#feature-hoc","content":" Block features may export HOC for apply this feature on base implementation of block.  Name pattern: with + ComponentName + FeatureName  Example  withMenuDesktopwithSelectDesktop  ","version":"Next","tagName":"h3"},{"title":"Class name constructor​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#class-name-constructor","content":" Block must export function which construct className property value for elements and modifiers  Name pattern: cn + ComponentName  Example  cnButtoncnTabMenu    ","version":"Next","tagName":"h3"},{"title":"Element​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#element","content":" ","version":"Next","tagName":"h2"},{"title":"Interface​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#interface-1","content":" Element must export interface with own props.  Name pattern: I + ComponentName + ElementName  Example  IButtonTextITabMenuItemText  ","version":"Next","tagName":"h3"},{"title":"Context​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#context","content":" Element may export context object which implement own interface.  It need to simplify deep forward props.  Name pattern: ComponentName + ElementName + Context  Example  SelectTriggerContextSelectListContext  ","version":"Next","tagName":"h3"},{"title":"Component​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#component-1","content":" Element must export object of type React.ComponentType which implement own interface.  Name pattern: ComponentName + ElementName  Example  ButtonTextTabMenuItemText    ","version":"Next","tagName":"h3"},{"title":"Modifier​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#modifier","content":" ","version":"Next","tagName":"h2"},{"title":"Interface​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#interface-2","content":" Modifier must export interface with props which add.  Name pattern: IMod + ComponentName + ModName  Example  IModButtonViewDefaultIModTabMenuViewAction  ","version":"Next","tagName":"h3"},{"title":"HOC​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#hoc","content":" Modifier must export HOC for apply to block.  Name pattern: withMod + ComponentName + ModName  Example  withModButtonViewActionwithModTabMenuViewDefault    ","version":"Next","tagName":"h3"},{"title":"Dependency injection registry​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#dependency-injection-registry","content":" ","version":"Next","tagName":"h2"},{"title":"Interface​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#interface-3","content":" Registry must export interface with items which it contains.  Feature specific registry (like platform registry) may extend common registry interface and add or redefine some items.  Name pattern: I + ComponentName + FeatureName + Registry  Example  IButtonRegistryITabMenuRegistry  Example with feature scope  IButtonDesktopRegistryITabMenuExperementalIconsRegistry  ","version":"Next","tagName":"h3"},{"title":"Registry​","type":1,"pageTitle":"Component naming and structure","url":"/react-elegant-ui/Component development/ComponentNaming#registry","content":" All registries (except index files) must export registry object.  Name pattern: ComponentName + FeatureName + Registry  Example  ButtonRegistryTabMenuRegistry  Example with feature scope  ButtonDesktopRegistryTabMenuExperementalIconsRegistry  Also, registry file may export object regObjects which contains all dependency objects ","version":"Next","tagName":"h3"},{"title":"Design system style guide","type":0,"sectionRef":"#","url":"/react-elegant-ui/Component development/DesignSystem","content":"","keywords":"","version":"Next"},{"title":"Independence of component tokens​","type":1,"pageTitle":"Design system style guide","url":"/react-elegant-ui/Component development/DesignSystem#independence-of-component-tokens","content":" Each component must have own namespace in design system and own tokens in this namespace for each customizable value.  Even if value already exist in common token, component should copy this value to own token and use this token in CSS instead direct use common token in CSS.  This allows flexible customization of the component. You can change specific tokens for any component instead change one token for all components.  This way have one disadvantage in some cases - all common tokens never use in CSS and make useless traffic. It may be fix with optional removing common tokens while compile. But this also can be useful when you use CSS aliases and wanna to dynamic change values, cuz in this case you have to change only common token values.  ","version":"Next","tagName":"h2"},{"title":"Cascade changes in tokens​","type":1,"pageTitle":"Design system style guide","url":"/react-elegant-ui/Component development/DesignSystem#cascade-changes-in-tokens","content":" Component tokens should not use literal values such as color or size, instead it use or modify common values.  This allows to make global changes by change common tokens.  You can use literal values for project defined tokens. It useful to personalization of design.  ","version":"Next","tagName":"h2"},{"title":"Token names​","type":1,"pageTitle":"Design system style guide","url":"/react-elegant-ui/Component development/DesignSystem#token-names","content":" Naming must be by meaning but not by value.  For example color of error message should name error instead red.  ","version":"Next","tagName":"h2"},{"title":"Name structure​","type":1,"pageTitle":"Design system style guide","url":"/react-elegant-ui/Component development/DesignSystem#name-structure","content":" Token name consists of parts and present a path in structure of design system.  First part of the struct it's token namespace. Next parts - it's just path to token key in namespace.  Example a component namespace:  buttoniconmenutextarea  To simplify navigation a tokens need group by purpose.  Typical groups:  typo: typography tokens like size and color of textfillColor: background colors of block, outline, etcsize: group for few sizes  Group may present a list of values or other groups like states list:  button: color: base: value: red hover: value: green focus: value: blue border: size: value: 2px style: value: solid color: base: value: red hover: value: green  ","version":"Next","tagName":"h2"},{"title":"Individual contributor license agreement","type":0,"sectionRef":"#","url":"/react-elegant-ui/Contributing/CLA","content":"Individual contributor license agreement You accept and agree to the following terms and conditions for Your present and future Contributions submitted to https://github.com/vitonsky. Except for the license granted herein to https://github.com/vitonsky and recipients of software distributed by https://github.com/vitonsky, You reserve all right, title, and interest in and to Your Contributions. Definitions: “You” (or “Your”) shall mean the copyright owner or legal entity authorized by the copyright owner that is making this Agreement with https://github.com/vitonsky. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, “control” means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. “Contribution” shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to https://github.com/vitonsky for inclusion in, or documentation of, any of the products owned or managed by https://github.com/vitonsky (the “Work”). For the purposes of this definition, “submitted” means any form of electronic, verbal, or written communication sent to https://github.com/vitonsky or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, https://github.com/vitonsky for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as “Not a Contribution.” Grant of Copyright License: Subject to the terms and conditions of this Agreement, You hereby grant to https://github.com/vitonsky and to recipients of software distributed by https://github.com/vitonsky a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License: Subject to the terms and conditions of this Agreement, You hereby grant to https://github.com/vitonsky and to recipients of software distributed by https://github.com/vitonsky a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contribution(s) alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that your Contribution, or the Work to which you have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that you are legally entitled to grant the above license. If your employer(s) has rights to intellectual property that you create that includes your Contributions, you represent that you have received permission to make Contributions on behalf of that employer, that your employer has waived such rights for your Contributions to https://github.com/vitonsky, or that your employer has executed a separate Corporate CLA with https://github.com/vitonsky. Contributions: You represent that each of Your Contributions is Your original creation. You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which you are personally aware and which are associated with any part of Your Contributions. Should You wish to submit work that is not Your original creation, You may submit it to https://github.com/vitonsky separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which you are personally aware, and conspicuously marking the work as “Submitted on behalf of a third-party: (insert_name_here)”. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You agree to notify https://github.com/vitonsky of any facts or circumstances of which you become aware that would make these representations inaccurate in any respect. This text is licensed under the Creative Commons Attribution 3.0 License and the original source is the Google Open Source Programs Office.","keywords":"","version":"Next"},{"title":"Component anatomy","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/ComponentArchitecture","content":"","keywords":"","version":"Next"},{"title":"Structure and bundles​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#structure-and-bundles","content":" Components developed by BEM methodology and split to Block, Elements and Modifiers. To use component, you have to build it with necessary features (Block, Elements and Modifiers).  That builds named a &quot;bundles&quot; and by default each component have at least 1 bundle with all features (except some very simply helper components).  You can use it for test components, but for production you should build your own bundles to decrease application bundle size and maybe use your own features.  ","version":"Next","tagName":"h2"},{"title":"Block​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#block","content":" Block it's main part of component which contains a must common logic  ","version":"Next","tagName":"h3"},{"title":"Elements​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#elements","content":" Elements it's components exists only inside block  ","version":"Next","tagName":"h3"},{"title":"Modifiers​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#modifiers","content":" Modifiers it's HOCs that define optional functional of block  ","version":"Next","tagName":"h3"},{"title":"Design tokens​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#design-tokens","content":" Design tokens contains a colors, sizes, typography and other values of component styles.  Component define a design tokens which compile to CSS properties that is use in styles of component.  This allows flexible redefine token values and reuse common values like project color or font size.  When you make your own elements, you can use exists or define new tokens.  ","version":"Next","tagName":"h2"},{"title":"Dependency registries​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#dependency-registries","content":" To decrease code dependency, objects must don't use other objects directly.  For example, while make Block extension which add features to basic block, we must make HOC for basic block and wrap basic block instead make component which use basic block inside.  This way allow apply this extension to other implementation of basic block.  But, when you need component inside other component, you can use dependency registry.  You just use provider to get object by name and still can set any object outside of component.  ","version":"Next","tagName":"h2"},{"title":"Assets​","type":1,"pageTitle":"Component anatomy","url":"/react-elegant-ui/Introduction/ComponentArchitecture#assets","content":" Component may contains some resources such as icons, fonts or shared code. It should be place in directories with clear names. For example ComponentName.hocs, ComponentName.assets.  Third-party assets must contains license texts and links to sources. ","version":"Next","tagName":"h2"},{"title":"Component development","type":0,"sectionRef":"#","url":"/react-elegant-ui/Component development/Introduction","content":"","keywords":"","version":"Next"},{"title":"Use strict typing​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#use-strict-typing","content":" Components written on typescript because strict types simplify maintenance.  When you wrong - you just can't compile code and in many cases you even don't need to check types in runtime, because successful compilation guarantee you many things.  But guarantees require high quality code with types which reflect domain specific.  Therefore you must write real types and try avoid any type, type casting and other hacks.  Typescript is very flexible language and allow you make complexity types. Usually TS features enought for any case. If you can't express something, check typescript docs or make issue to discuss your problem.  ","version":"Next","tagName":"h2"},{"title":"Write stupid code​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#write-stupid-code","content":" Maintain complexity is very important parameter of code, it's literally define future of code base.  Code complexity and its diversity is a key factors of code base hard for maintenance.  The simply stupid code the better. Under stupid mean its clear and simplicity.  We can use linters and tools which control codestyle, but we can't prevent all cases with complexity code, especially since sometime we have to write complexity code for performance purposes.  Please, don't write beautiful and smart code which require time to understand.  Your code must be simple, obviously and monosemantic. What would people read it and don't think what means your construction.  For example, x === -1 better than !~x, because we shouldn't parse syntax and build logical pipeline with negation of negation, follow the logic and other things. We just see statement and understand it instantly.  Your code is nothing and will replace in any time. At least because tomorrow it will be deprecated. Keep it in mind when write code and focus on functionality and clearly. Functional will keep forever.  ","version":"Next","tagName":"h2"},{"title":"Comment all​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#comment-all","content":" If you have to write not trivial code or use hack, explain it.  When you make public essence such as function, class or other object, add doc block for it.  When you change a exists public essence and it change behavior or signature, update description of it.  If you not wanna do something right now, but see that it needful or would be usefull, make TODO comment with explain of it.  If you don't sure about something, comment it and say about. It's fine, someone later improve it, maybe you or not.  If you see suboptimal things, make TODO comment with tag #perf and explain problems. Criticism to code it's fine and help to make code better. But please, explain points, but not just insult a code because it useless information.  ","version":"Next","tagName":"h2"},{"title":"Specify licenses and authors for thirdparty resources​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#specify-licenses-and-authors-for-thirdparty-resources","content":" We respect authors of thirdparty resources and require specify license and authors for any thirdparty resources. Not matter what is it. It may be icons, fonts, images, libraries, parts of code or other. You must add this information for any resource and resource license must allow use resource anywhere.  Remember that you are responsible for check licenses and author rights. If you find resource on some random site and there say that this resource is free to use anywhere it's mean nothing. You must reference to source of each resource and this must contains license agreement.  This is to ensure fair usage.    Components development principles  For info about development components see component naming and structure.  More info about components in component anatomy and component file structure.  If you still don't, must read BEM methodology to understand terms and architecture of components.  ","version":"Next","tagName":"h2"},{"title":"Blocks​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#blocks","content":" For control a class names of components use library @bem-react/classname, make cn object in basic implementation of component and use it in other essences.  ","version":"Next","tagName":"h2"},{"title":"Minimal implementation​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#minimal-implementation","content":" Block it's root of component and should implement minimal common features of component.  If you want implement feature which will use only on desktop, such as keyboard navigation, do it in feature file with feature name postfix in name, for example Button@desktop.tsx, Button@touch.tsx, Button@someExperementName.tsx.  ","version":"Next","tagName":"h3"},{"title":"Elements​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#elements","content":" Move all elements to separate components, even if it very simply block.  It need to user can replace element to other implementation.  ","version":"Next","tagName":"h2"},{"title":"Modifiers​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#modifiers","content":" Modifiers should be a High Order Components (HOC).  Modifiers should self remove all own props which not declared in basic block interface and don't forward it.  You can use compose library to define HOCs which will apply by match props values and auto remove own properties when not match.    Reuse  ","version":"Next","tagName":"h2"},{"title":"Keep state outside​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#keep-state-outside","content":" Keep state outside and make requests to change state inside.  If don't do it, component will keep private state and wrappers can't control component and component stay unextendable.  You can keep inside a state which specific only for this entity, but all public properties states must keep outside.  ","version":"Next","tagName":"h2"},{"title":"Split to features​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#split-to-features","content":" Component can't have features for any case, because number of cases is infinity.  Instead this component should be designed extensible and implement only basic features.  All other may be implement as wrappers which add features.  This design allows add features for any case.  Default implementation of some feature in library don't like for you? It's fine, you don't need to fork library, replace some details in this implementation and support it self, just replace feature to your own implementation and it all. You can copy code of default implementation, replace details and use as your own feature which work as you wish.  If basic block layout bad for your case, just use your own implementation, you need only replace it with compose.  ","version":"Next","tagName":"h2"},{"title":"Use wrappers​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#use-wrappers","content":" When you implement block feature, you need block to wrap it. But you must not direct use block inside implementation. It make feature not applyable for other block implementation.  Instead this make HOC for block, export it, apply to block and export wrapped block.  This way allow to user apply this feature to any block which implement interface of basic block.  ","version":"Next","tagName":"h2"},{"title":"Move common logic outside​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#move-common-logic-outside","content":" Some UI logic need in many components. When you catch this, just move this logic to library, unify it and use library in same cases.  Better if you make library which not bind to framework and then adopt it to this, for example make behavior hook. This way allow you collect behavior logic and use it indepedent of framework features and even indepedent of framework, for example in pure JS.  Good example of this it is popperjs which can be use in pure js, react or any other library.  ","version":"Next","tagName":"h2"},{"title":"Use common interfaces​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#use-common-interfaces","content":" When interface have typical properties, use extends the coommon interfaces like IComponentElement  This unify properties and simplify global refactoring, because you can refactor only one interface and changes will apply to all implementations  ","version":"Next","tagName":"h2"},{"title":"Make extenson nodes​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#make-extenson-nodes","content":" When you build component think about how users may want extend this.  To extend component often need add child nodes, then add props which give component and render in some place inside.  You can use names start from addon: addonBefore, addonAfter, addonBeforeControl, addonAfrerWrapper  ","version":"Next","tagName":"h2"},{"title":"Forward all​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#forward-all","content":" When you make wrapper, probably you insert to basic element some props.  Don't forget forward user props with same names. You should make mix from your value and user value.  If it class name join it, if it callback, make call chain from your and user callback, if it context, mix context values but don't lose user values.  ","version":"Next","tagName":"h2"},{"title":"Class component vs functional​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#class-component-vs-functional","content":" You can make components of any type, class components, functional components or both.  But functional components have hooks and very convenient move common ligic to hooks and use it everywhere.  Also, functional components is simply, so this library use mostly functional components.  But you can mix this.    Abstract components and replaceable  Use design tokens  ","version":"Next","tagName":"h2"},{"title":"Component incapsulation and autonomy​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#component-incapsulation-and-autonomy","content":" Component it's standalone entity and must be indepedent from all other.  It mean that component must contain all self parts such as code, styles, design tokens, docs, and other resources.  Component must consist from parts which can be replace to other implementations and end features can be define only while make bundle.  ","version":"Next","tagName":"h2"},{"title":"Use contexts to props forwarding​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#use-contexts-to-props-forwarding","content":" Components may use many wrappers and to forward props to some element you should use contexts.  Just make context contains props while make element and use it inside. And when you need to set props on element, use context provider for it.  ","version":"Next","tagName":"h2"},{"title":"Use DI​","type":1,"pageTitle":"Component development","url":"/react-elegant-ui/Component development/Introduction#use-di","content":" When you need some object, like element, you shall not use it directly never.  Instead this use dependency injection containers.  It allows you replace objects while composing.  Don't make types for DI which have all possible objects. Instead make type for basic components and standalone types for each feature and union this types while make bundle.  This way allows to users set only necessary objects in their registry.  See more info in DI library docs ","version":"Next","tagName":"h2"},{"title":"Component file structure","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/ComponentFileStructure","content":"","keywords":"","version":"Next"},{"title":"File structure​","type":1,"pageTitle":"Component file structure","url":"/react-elegant-ui/Introduction/ComponentFileStructure#file-structure","content":" ComponentName.tsx - basic component (block)__examples__ - directory with examples a usage of componentsComponentName@platform.tsx - basic platform-specific version of component that extends a basic component_modName - directory of boolean modifier with name modName ComponentName_modName.css - styles of modComponentName_modName.tsx - declaration of mod _otherModName - directory of key-value modifier with name otherModName ComponentName_otherModName_value1.css - styles of mod with value value1ComponentName_otherModName_value1.tsx - declaration of mod with value value1ComponentName_otherModName_value2.css - styles of mod with value value2ComponentName_otherModName_value2.tsx - declaration of mod with value value2 ElementName - directory of element with name ElementName _modName - directory of boolean modifier with name modName for element ElementName ElementName_modName.css - styles of modElementName_modName.tsx - declaration of mod ElementName.css - styles of elementElementName.tsx - declaration of element ComponentName.assets - directory with resources of components, such as images, fonts, etc.ComponentName.bundle - directory with composed components with all features, named by pattern platform.tsx platform.ts - contains composed component for a specific platform ComponentName.docs - directory with additional docsComponentName.hocs - directory with High Order Components for this blockComponentName.registry - directory for DI files index.ts - contains only registry interface, without implementationplatform.ts - contains registry object for a specific platform ComponentName.tests - directory with tests of componentComponentName.tokens - directory with design tokens for component  Under platform.tsx meaning name for specific platform, for example desktop.tsx, mobile.tsx or touch.tsx.  Here displays file structure examples of source, therefore used .ts and .tsx files, but package contains compiled .js files with .d.ts headers. ","version":"Next","tagName":"h2"},{"title":"Contributing rules","type":0,"sectionRef":"#","url":"/react-elegant-ui/Contributing/ContributingRules","content":"","keywords":"","version":"Next"},{"title":"PR rules​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#pr-rules","content":" You can make pull request (PR), but if your PR have big changes, in first you should discuss it in issues, because maybe we already fix it or planned work on it.  Before making PR, check exists PRs, maybe it already resolved.  Before send your changes you must read CONTRIBUTING.md in root directory of repository and accept rules.  Common rules:  Write in detail about your work in PR description with examples if it possible Your PR should change only one thing and shouldn't affect to other exists library components Follow the component development rules while write code Comment your code. It help for all to understand and maintain your code This is especially important for hacks and unobvious code Use readable names for variables, functions, classes, etc. Follow the commit rules bellow  Your changes also must follow next rules  ","version":"Next","tagName":"h2"},{"title":"Scope of usage​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#scope-of-usage","content":" Your contributions in this repo must be for common usage, for many cases.  For example, PR with change color of button will reject, cuz users can change color in their projects, it not required changes on library level.  We can't add features for all cases at least because every feature require maintain.  If we can't accept your changes due to not common scope, please, don't be upset and make library that have this library as peer dependency and implement your feature there. It will good for all and you can collect features for your scope in your own library.  Scoped addons can be useful for you and other people, but not make maintain of this library harder. You can tag us in npm and make issue with description of your addon package and we tell about it.  ","version":"Next","tagName":"h3"},{"title":"Breaking changes​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#breaking-changes","content":" Before write code with breaking changes you must make issue for discuss this.  We can accept that changes, but only if you can proof that it useful changes which improve library.  If you want make changes that break many things, it's not problem, but please, write detail migration guide before this for we can estimate cost of this changes and find good time for accept.  ","version":"Next","tagName":"h3"},{"title":"New features​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#new-features","content":" When you want to add new features to exists components, you must not change this components.  Instead this just add wrapper or alternative implementation of object which implement interface of original.  ","version":"Next","tagName":"h3"},{"title":"Unify​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#unify","content":" If you can't extend exists object and you sure that it can be unify, you can make issue for discuss this changes and if we decide that this changes is required for common usage, then changes will accept and you can implement your feature.  When you find problems with unify of interfaces or implementations of components and make issue about it, you very help to unify components.  Some components can't be unify for all cases, but we must seek to it and keep balance between unify and size of implementation. Cuz when user can't use implementation for own features, user will make own implementation and this should be easy for him.  ","version":"Next","tagName":"h3"},{"title":"Commit rules​","type":1,"pageTitle":"Contributing rules","url":"/react-elegant-ui/Contributing/ContributingRules#commit-rules","content":" Use conventional commits rules.  The commit message should be structured as follows:  &lt;type&gt;[optional scope]: &lt;description&gt; [optional body]   Commit types  fixfeattestrefactordocschore ","version":"Next","tagName":"h2"},{"title":"Package structure","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/PackageStructure","content":"","keywords":"","version":"Next"},{"title":"Components​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#components","content":" Directory components contains a component directories with all them files. Sub-directories named by component names, for example Button, Menu, Select.  For more info see component anatomy and component file structure.  ","version":"Next","tagName":"h2"},{"title":"Hooks​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#hooks","content":" Directory hooks contains a react hooks useful for development UI components.  Subdirectory behavior contains a react hooks which implement typical behavior of UI components.  It very useful and allow share common logic of components. When you make some not trivial logic, check this first, maybe this already implemented as behavior hook. If not, but logic which you implement very common and may reuse for other components, make issue with explain to move this logic in hook.  ","version":"Next","tagName":"h2"},{"title":"HOCs​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#hocs","content":" Directory hoks contains collection of utility high order components.  ","version":"Next","tagName":"h2"},{"title":"Libraries​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#libraries","content":" Directory lib contains useful libraries.  ","version":"Next","tagName":"h2"},{"title":"Theme​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#theme","content":" Directory theme contains a common design tokens and themes for standard library components.  ","version":"Next","tagName":"h2"},{"title":"Polyfills​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#polyfills","content":" Directory polyfills contains a browser-specific libraries.  ","version":"Next","tagName":"h2"},{"title":"Types​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#types","content":" Directory types contains a library TypeScript types.  ","version":"Next","tagName":"h2"},{"title":"CJS/ES modules​","type":1,"pageTitle":"Package structure","url":"/react-elegant-ui/Introduction/PackageStructure#cjses-modules","content":" Package contains CJS and ES modules, for use ES modules, add prefix /esm in path to component  Example of import default bundle a Button component as ES module  import { Button } from 'react-elegant-ui/esm/components/Button/Button.bundle/desktop';   You may need CJS modules for server side rendering, but use ES modules for build tools (WebPack, Rollup, etc.), because ESM is supporting tree shaking. ","version":"Next","tagName":"h2"},{"title":"Design tokens","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/Tokens","content":"","keywords":"","version":"Next"},{"title":"Principles​","type":1,"pageTitle":"Design tokens","url":"/react-elegant-ui/Introduction/Tokens#principles","content":" Design tokens it's just some abstract dictionary with names and values which define view of components.  This UI kit use YAML files to define design tokens in style-dictionary format. This format allows reference to other tokens and use functions for handle values, for example change brightness of color or convert units.  All tokens define in files with extension .tokens.yml.  Each component contains files with own tokens.  Directory tokens contains a common tokens which use in components.  Tokens must use namespaces.  For components it their namesFor common tokens it their domain of usage  ","version":"Next","tagName":"h2"},{"title":"Usage​","type":1,"pageTitle":"Design tokens","url":"/react-elegant-ui/Introduction/Tokens#usage","content":" Tokens may convert to any format such as CSS custom properties, XML, JSON, JS, etc.  For compile themes from tokens use theme library.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Design tokens","url":"/react-elegant-ui/Introduction/Tokens#example","content":" Typical example of design tokens file  button: # Define transitions speed transition: press: value: '250ms' hover: value: '{transition.controls.action.hover.size.s.in.value}' border: width: value: '{typography.controls.border.width.s.value}' # Make square button radius: value: '0' # Define style for action button with view `action` viewAction: fillColor: base: value: '#ffd11a' hovered: value: '#ff6464' disabled: value: '#ffe991' typoColor: base: value: '#000'  ","version":"Next","tagName":"h2"},{"title":"Theming","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/Theming","content":"","keywords":"","version":"Next"},{"title":"Fallback​","type":1,"pageTitle":"Theming","url":"/react-elegant-ui/Introduction/Theming#fallback","content":" For use themes browser must support CSS variables, but if you need to use UI kit for old browsers which is not support this (IE9 for example), you can compile CSS variables to static values.  For this case you can use PostCSS plugin postcss-theme-fold.  ","version":"Next","tagName":"h2"},{"title":"Tools​","type":1,"pageTitle":"Theming","url":"/react-elegant-ui/Introduction/Theming#tools","content":" You can use any tools to convert design tokens to themes such as design tokens it's just YAML files.  Actually design tokens use references to other tokens and functions for transform values, but it not too hard to implement.  This package is use a themekit tool which based on style-dictionary. ","version":"Next","tagName":"h2"},{"title":"Getting started","type":0,"sectionRef":"#","url":"/react-elegant-ui/Introduction/GettingStarted","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#install","content":" Install package and peer deps  npm install react-elegant-ui @bem-react/classname react  ","version":"Next","tagName":"h2"},{"title":"Basic usage​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#basic-usage","content":" Each component have a ready-made bundle with all features, you can use it.  It useful for prototyping, library overview, developer purposes, for see on code samples. But should not use it in your real projects, better make your own components bundles.  Use library in your application:  import React, { useState } from 'react'; // Import prebuilded components with all features import { Textinput } from 'react-elegant-ui/esm/components/Textinput/Textinput.bundle/desktop'; import { Button } from 'react-elegant-ui/esm/components/Button/Button.bundle/desktop'; import { configureRootTheme } from 'react-elegant-ui/esm/theme'; import { theme } from 'react-elegant-ui/esm/theme/presets/default'; // Use global theme. It's client side only feature configureRootTheme({ theme }); export const Example = () =&gt; { const [name, setName] = useState(''); const clear = () =&gt; setName(''); const clickHandler = () =&gt; console.log(name ? `Hello, ${name}` : 'Input your name'); return &lt;div&gt; &lt;Textinput placeholder=&quot;Input your name&quot; value={name} setValue={setName} hasClear onClearClick={clear} /&gt; &lt;Button view=&quot;action&quot; onClick={clickHandler}&gt;Say my name&lt;/Button&gt; &lt;/div&gt;; }   Then just build it in your favorite bundler and use.  You will require bundler modules for handle JS or TSX, CSS and for convert SVG files to components.  If you have problems with build process, see webpack config in examples and make issue if it not resolve your problem.  ","version":"Next","tagName":"h2"},{"title":"Advanced usage​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#advanced-usage","content":" Main feature of this components is architecture which split components to features and allow you use components with only features which you really need.  For example, when you make page for smartphones, usually you are not necessary features which implement keyboard navigation different of pages for desktop and you want use native select control instead custom and probably bigger buttons.  You can handle useragent header of requests on server side and give bundles depends of it. For smartphons one for desktop browsers other, for old browsers give bundle with polyfils and fallbacks, for modern - with all modern features.  This way allow you decrease bundle size, speed up page loading and use experements, when you test features on part of users.  If you don't want it, it's fine, just use one bundle everywhere if you want but for you it useful too.  This architecture mean also that you can add new features to exists components or replace implementation of some features.  You need menu with search input down of menu, and by default exists feature with search input but this input add before menu and it not satisfied you? It's not problem, because you can fix it very simply and fast, just take source code of this feature from repo, change as you wish and build component with your implementation of this feature. It take about 5 minuts.  ","version":"Next","tagName":"h2"},{"title":"Build​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#build","content":" All that you need to use component with some features is compose component and features which you need. That builds named a bundles.  Example of build in your project file myApp/components/Button/Button.bundle/desktop.ts  // Import tools from compose library import { compose, composeU, ExtractProps, } from 'react-elegant-ui/esm/lib/compose'; // Import tool from DI library // See docs: https://github.com/bem/bem-react/tree/master/packages/di import { withRegistry } from 'react-elegant-ui/esm/lib/di'; // Import base component import { Button as DesktopButton } from 'react-elegant-ui/esm/components/Button/Button@desktop'; // DI registry object import { ButtonDesktopRegistry } from 'react-elegant-ui/esm/components/Button/Button.registry/desktop'; // Modifiers view import { withModButtonViewDefault } from 'react-elegant-ui/esm/components/Button/_view/Button_view_default'; import { withModButtonViewAction } from 'react-elegant-ui/esm/components/Button/_view/Button_view_action'; // Modifiers size import { withModButtonSizeS } from 'react-elegant-ui/esm/components/Button/_size/Button_size_s'; import { withModButtonSizeM } from 'react-elegant-ui/esm/components/Button/_size/Button_size_m'; // Some local feature import { withModButtonSizeL } from '../_size/Button_size_l'; // Modifier width import { withModButtonWidthMax } from 'react-elegant-ui/esm/components/Button/_width/Button_width_max'; // Export all objects from base component export * from 'react-elegant-ui/esm/components/Button/Button@desktop'; // Build base component `DesktopButton` with specified features // Every feature it's just HOC export const Button = compose( // Make HOC with this registry // Every feature after this can use this registry withRegistry(ButtonDesktopRegistry), // Apply only one HOC, which will first match for props composeU(withModButtonViewDefault, withModButtonViewAction), composeU(withModButtonSizeS, withModButtonSizeM, withModButtonSizeL), // Apply HOC always withModButtonWidthMax, )(DesktopButton); // Set default properties for composed component Button.defaultProps = { size: 'm', view: 'default' }; // Export new type of component with all features export type IButtonProps = ExtractProps&lt;typeof Button&gt;;   Example of use in your project file myApp/app.tsx  import { Button } from './components/Button/Button.bundle/desktop'; // ...   ","version":"Next","tagName":"h3"},{"title":"Make your own feature​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#make-your-own-feature","content":" All features it's just HOCs.  Example of simply feature myApp/components/Button/_size/Button_size_l.tsx  import React, { ComponentType, FC } from 'react'; // Import helper for make BEM classname and button interface import { cnButton, IButtonProps, } from 'react-elegant-ui/esm/components/Button/Button'; // Include styles in bundle with use feature import './Button_size_l.css'; // Interface of feature export interface IModButtonSizeL { size?: 'l'; } export const withModButtonSizeL = ( BaseComponent: ComponentType&lt;IButtonProps&gt;, // You must remove feature properties to prevent forwarding ): FC&lt;IModButtonSizeL &amp; IButtonProps&gt; =&gt; ({ size, ...props }) =&gt; { // do something if you need // ... return ( &lt;BaseComponent {...props} // add modifier to `className` className={cnButton({ size }, [props.className])} /&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Smart HOC​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#smart-hoc","content":" Features may be complexity. You may use many features which trigger by one property and you may wish apply only one feature from this. For example, when you have 3 size modifier, as in example above.  For this cases, you can add to your HOC a utility property which describe apply rules.  Use for this a helper withHOCConstructor from library compose.  Example of feature myApp/components/Button/_size/Button_size_l.tsx  import React, { ComponentType, FC } from 'react'; // Import helper for make BEM classname and button interface import { cnButton, IButtonProps, } from 'react-elegant-ui/esm/components/Button/Button'; // Use helper import { withHOCConstructor } from 'react-elegant-ui/esm/lib/compose'; // Include styles in bundle with use feature import './Button_size_l.css'; // Interface of feature export interface IModButtonSizeL { size?: 'l'; } export const withModButtonSizeL = withHOCConstructor&lt; IModButtonSizeL, IButtonProps &gt;( { // apply this HOC only by match with this props state matchProps: { size: 'l' }, // make all props names from `matchProps` is private // it's mean that when no one feature which use this props will not match // this props will auto remove privateMatchProps: true, }, // Types will infer automatically // You still must remove feature properties to prevent forwarding (BaseComponent) =&gt; ({ size, ...props }) =&gt; { // do something if you need // ... return ( &lt;BaseComponent {...props} className={cnButton({ size }, [props.className])} /&gt; ); }, );   ","version":"Next","tagName":"h3"},{"title":"Simply visual features​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#simply-visual-features","content":" Many visual features just import styles and extends className property.  For this cases you can use helper withClassnameHOC from library compose.  Example of simply visual feature myApp/components/Button/_size/Button_size_l.tsx  // Use helper import { withClassnameHOC } from 'react-elegant-ui/esm/lib/compose'; // Import helper for make BEM classname import { cnButton } from '../Button'; // Include styles in bundle with use feature import './Button_size_l.css'; // Interface of feature export interface IModButtonSizeL { size?: 'l'; } // By match with props state will apply HOC which extend `className` property. // This example do same as example above export const withModButtonSizeL = withClassnameHOC&lt;IModButtonSizeL&gt;( cnButton(), { size: 'l', }, );   ","version":"Next","tagName":"h3"},{"title":"Docs​","type":1,"pageTitle":"Getting started","url":"/react-elegant-ui/Introduction/GettingStarted#docs","content":" For more info about development of features and components see component development docs section.  Each component directory contains .md files with documentation. See there if you wanna know about specific component.  For look at demo of components, you can build examples, see directory examples. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}